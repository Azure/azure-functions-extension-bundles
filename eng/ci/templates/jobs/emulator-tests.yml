# Azure Functions Extension Bundle - Parallel Emulator Tests CI Job Template
#
# This template runs emulator-based tests in parallel using matrix strategy
# Each test group runs with its required emulators to optimize execution time
# Azurite (Storage) and EventHub are started for all test groups as base requirements
parameters:
  - name: official
    type: boolean
    default: false

  - name: poolName
    type: string

jobs:
  # New preparation job to build/publish once for all matrix runs
  - job: PrepareEmulatorTestAssets
    displayName: Prepare Emulator Test Assets (build once)
    pool:
      name: ${{ parameters.poolName }}
      image: 1es-ubuntu-22.04
      os: linux
    templateContext:
      outputParentDirectory: $(Build.ArtifactStagingDirectory)
      outputs:
        - output: pipelineArtifact
          displayName: Publish bundle artifacts
          path: $(Build.Repository.LocalPath)/artifacts
          artifact: bundle-artifacts
        - output: pipelineArtifact
          displayName: Publish bundle bin
          path: $(Build.Repository.LocalPath)/bin
          artifact: bundle-bin
        - output: pipelineArtifact
          displayName: Publish templates artifacts
          path: $(Build.Repository.LocalPath)/templatesArtifacts
          artifact: templates-artifacts

    steps:
      # Download template artifacts for the build
      # Official templates
      - task: DownloadBuildArtifacts@1
        displayName: 'Download Official Templates'
        inputs:
          buildType: 'specific'
          project: '3f99e810-c336-441f-8892-84983093ad7f'
          pipeline: '963'
          buildVersionToDownload: 'latestFromBranch'
          branchName: 'refs/heads/dev'
          downloadType: 'single'
          artifactName: 'drop'
          downloadPath: '$(Build.Repository.LocalPath)/templatesArtifacts'
        condition: ${{ parameters.official }}

      # Public templates
      - task: DownloadBuildArtifacts@1
        displayName: 'Download Public Templates'
        inputs:
          buildType: 'specific'
          project: 'ae7e3bf3-d41a-4480-9ac0-b6cf9df9ac24'
          pipeline: '976'
          buildVersionToDownload: 'latestFromBranch'
          branchName: 'refs/heads/dev'
          downloadType: 'single'
          artifactName: 'drop'
          downloadPath: '$(Build.Repository.LocalPath)/templatesArtifacts'
        condition: ${{ eq(parameters.official, false) }}

      - task: NuGetAuthenticate@1
        displayName: 'NuGet Authenticate'
 
      # Build the Linux bundle first
      - task: DotNetCoreCLI@2
        displayName: 'Build Linux Bundle (once)'
        inputs:
          command: 'run'
          workingDirectory: './build'
          arguments: 'PackageBundlesLinux'
        env:
          BUILD_REPOSITORY_LOCALPATH: '$(Build.Repository.LocalPath)'
          TEMPLATES_ARTIFACTS_DIRECTORY: '$(Build.Repository.LocalPath)/templatesArtifacts'

      - script: |
          echo "Checking for build artifacts..."
          if ls artifacts/*.zip 2>/dev/null || ls bin/*/*.zip 2>/dev/null; then
            echo "✓ Extension bundle artifacts found"
          else
            echo "✗ No extension bundle zip files found anywhere"
            exit 1
          fi
        displayName: 'Verify Build Artifacts'

      # Matrix job now depends on the preparation job and reuses its artifacts
  - job: EmulatorTests
    displayName: Run Emulator Tests
    dependsOn: PrepareEmulatorTestAssets
    pool:
      name: ${{ parameters.poolName }}
      image: 1es-ubuntu-22.04
      os: linux

      # Matrix strategy for parallel execution by emulator group
      strategy:
        matrix:
          BasicTests:
            TEST_GROUP: 'basic'
            TEST_FILES: 'test_blob_functions.py test_connectivity.py test_eventhub_batch_functions.py test_eventhub_functions.py test_queue_functions.py test_table_functions.py'
            ADDITIONAL_EMULATORS: 'none'
            DISPLAY_NAME: 'Basic Tests (Azurite + EventHub)'
            STOP_EVENTHUB: 'false'
          CosmosDB:
            TEST_GROUP: 'cosmosdb'
            TEST_FILES: 'test_cosmosdb_functions.py'
            ADDITIONAL_EMULATORS: 'cosmosdb'
            DISPLAY_NAME: 'CosmosDB Tests'
            STOP_EVENTHUB: 'false'
          MySQL:
            TEST_GROUP: 'mysql'
            TEST_FILES: 'test_mysql_functions.py'
            ADDITIONAL_EMULATORS: 'mysql'
            DISPLAY_NAME: 'MySQL Tests'
            STOP_EVENTHUB: 'false'
          ServiceBus:
            TEST_GROUP: 'servicebus'
            TEST_FILES: 'test_servicebus_functions.py'
            ADDITIONAL_EMULATORS: 'servicebus'
            DISPLAY_NAME: 'Service Bus Tests'
            STOP_EVENTHUB: 'true'
          DTS:
            TEST_GROUP: 'durable'
            TEST_FILES: 'test_durable_functions.py'
            ADDITIONAL_EMULATORS: 'dts'
            DISPLAY_NAME: 'DTS Tests'
            STOP_EVENTHUB: 'false'

      templateContext:
        outputParentDirectory: $(Build.ArtifactStagingDirectory)
        outputs:
          - output: pipelineArtifact
            displayName: Publish emulator test artifacts for $(TEST_GROUP)
            path: $(Build.ArtifactStagingDirectory)
            artifact: emulator-test-results-$(TEST_GROUP)

      steps:
        # Initial listing for debugging (added)
        - script: |
            echo "=== Initial workspace listing ==="
            pwd
            ls -al .
            for d in artifacts bin templatesArtifacts tests; do
              echo "--- $d ---";
              ls -al "$d" 2>/dev/null || echo "(missing)"; done
          displayName: 'Initial Workspace Listing'

        # Download prepared artifacts (instead of rebuilding)
        - task: DownloadPipelineArtifact@2
          displayName: 'Download bundle artifacts'
          inputs:
            artifact: 'bundle-artifacts'
            path: '$(Build.Repository.LocalPath)/artifacts'

        - task: DownloadPipelineArtifact@2
          displayName: 'Download bundle bin'
          inputs:
            artifact: 'bundle-bin'
            path: '$(Build.Repository.LocalPath)/bin'

        - task: DownloadPipelineArtifact@2
          displayName: 'Download templates artifacts'
          inputs:
            artifact: 'templates-artifacts'
            path: '$(Build.Repository.LocalPath)/templatesArtifacts'

        - script: |
            echo "Listing downloaded directories..."
            ls -al artifacts || true
            ls -al bin || true
            ls -al templatesArtifacts || true
            echo "Checking for downloaded artifacts..."
            if ls artifacts/*.zip 2>/dev/null || ls bin/*/*.zip 2>/dev/null; then
              echo "✓ Extension bundle artifacts downloaded"
              echo "Artifacts:"
              ls -1 artifacts/*.zip 2>/dev/null || true
              ls -1 bin/*/*.zip 2>/dev/null || true
            else
              echo "✗ No extension bundle zip files found"
              find . -maxdepth 5 -type f -name '*.zip' -print || true
              exit 1
            fi
          displayName: 'Verify Downloaded Artifacts'

        # Set up Python 3.12 and create virtual environment
        - task: UsePythonVersion@0
          inputs:
            versionSpec: '3.12'
            addToPath: true
            architecture: 'x64'
          displayName: 'Set up Python 3.12'

        - script: |
            cd tests
            python -m venv venv
            source venv/bin/activate
            pip install --upgrade pip
            pip install --cache-dir ~/.cache/pip -r requirements.txt
          displayName: 'Install Python Dependencies (cached)'
        # Start base emulators (Azurite + EventHub) - Required for ALL test groups
        - script: |
            echo "Starting base emulators (Azurite + EventHub) for $(DISPLAY_NAME)..."
            cd tests/emulator_tests/utils/eventhub
            docker compose pull
            docker compose up -d
            echo "Waiting for base emulator services to start..."
            sleep 30
            docker compose ps
            echo "Base emulators started successfully"
          displayName: 'Start Base Emulators (Azurite + EventHub)'
        # Conditionally start additional emulators based on test group
        - script: |
            if [ "$(ADDITIONAL_EMULATORS)" = "cosmosdb" ]; then
              echo "Starting CosmosDB Emulator for $(DISPLAY_NAME)..."
              docker pull mcr.microsoft.com/cosmosdb/linux/azure-cosmos-emulator:vnext-preview
              docker run --detach --publish 8081:8081 --publish 1234:1234 --name cosmosdb-emulator mcr.microsoft.com/cosmosdb/linux/azure-cosmos-emulator:vnext-preview
              echo "Waiting for CosmosDB Emulator to start..."
              sleep 60
              docker ps
            elif [ "$(ADDITIONAL_EMULATORS)" = "mysql" ]; then
              echo "Starting MySQL Emulator for $(DISPLAY_NAME)..."
              cd tests/emulator_tests/utils/mysql
              docker compose up -d
              echo "Waiting for MySQL service to start..."
              sleep 30
              docker compose ps
            elif [ "$(ADDITIONAL_EMULATORS)" = "servicebus" ]; then
              # Stop EventHub first to avoid port conflicts
              if [ "$(STOP_EVENTHUB)" = "true" ]; then
                echo "Stopping EventHub Emulator to free up ports for Service Bus..."
                docker stop eventhubs-emulator || true
                docker container rm --force eventhubs-emulator || true
              fi
              
              echo "Starting Service Bus Emulator for $(DISPLAY_NAME)..."
              cd tests/emulator_tests/utils/servicebus
              docker compose pull
              docker compose up -d
              echo "Waiting for Service Bus emulator to start..."
              sleep 30
              docker compose ps
            else
              echo "No additional emulators required for $(DISPLAY_NAME)"
            fi
          displayName: 'Start Additional Emulators'
          env:
            AzureWebJobsSQLPassword: $(AzureWebJobsSQLPassword)
        - script: |
            cd tests
            source venv/bin/activate
            echo "Starting mock extension site on port 8000 for $(DISPLAY_NAME)..."

            python -m invoke -c test_setup mock-extension-site --port 8000 &

            MOCK_SITE_PID=$!
            echo "Mock site started with PID: $MOCK_SITE_PID"
            echo "##vso[task.setvariable variable=MOCK_SITE_PID]$MOCK_SITE_PID"
            sleep 10

            # Verify mock site is running on port 8000
            if curl -f http://localhost:8000/ 2>/dev/null; then
              echo "Mock extension site is running successfully on port 8000"
              echo "Extension bundle source URI: http://localhost:8000"
            else
              echo "Warning: Mock extension site may not be responding on port 8000"
              ps aux | grep mock-extension-site
              netstat -tlnp | grep :8000 || true
            fi
          displayName: 'Start Mock Extension Site'

        # Set up webhost
        - script: |
            cd tests
            source venv/bin/activate
            python -m invoke -c test_setup webhost
          displayName: 'Setup WebHost'
        # Run tests for this specific test group
        - script: |
            cd tests
            source venv/bin/activate
            cd ..
            export PYAZURE_WEBHOST_DEBUG=1
            export FUNCTIONS_EXTENSIONBUNDLE_SOURCE_URI="http://localhost:8000"
            export MySqlConnectionString="Server=localhost;UserID=root;Password=password;Database=testdb;Port=3307"
            IFS=' ' read -ra FILES <<< "$(TEST_FILES)"
            TEST_PATHS=""
            for file in "${FILES[@]}"; do
              TEST_PATHS="$TEST_PATHS tests/emulator_tests/$file"
            done
            echo "Running pytest with paths: $TEST_PATHS"
            python -m pytest $TEST_PATHS -v --tb=short --junitxml=$(Build.ArtifactStagingDirectory)/test-results-$(TEST_GROUP).xml
          displayName: 'Run $(DISPLAY_NAME) Tests'
          env:
            PYAZURE_WEBHOST_DEBUG: 1
            FUNCTIONS_EXTENSIONBUNDLE_SOURCE_URI: 'http://localhost:8000'
            AzureWebJobsStorage: 'UseDevelopmentStorage=true'
            AzureWebJobsEventHubConnectionString: $(EmulatorEventHubConnectionString)
            AzureWebJobsCosmosDBConnectionString: $(EmulatorCosmosDBConnectionString)
            AzureWebJobsServiceBusConnectionString: $(EmulatorServiceBusConnectionString)
            AzureWebJobsSQLPassword: $(AzureWebJobsSQLPassword)
            CosmosDBEmulatorUrl: $(CosmosDBEmulatorUrl)
            CosmosDBEmulatorKey: $(CosmosDBEmulatorKey)

        # Copy webhost config for debugging
        - script: |
            if [ -f tests/webhost_config.txt ]; then
              cp tests/webhost_config.txt $(Build.ArtifactStagingDirectory)/
              echo "WebHost config copied for artifact upload"
            else
              echo "Warning: webhost_config.txt not found"
            fi
          displayName: 'Copy WebHost Config'
          condition: always()

        # Publish test results
        - task: PublishTestResults@2
          inputs:
            testResultsFiles: '$(Build.ArtifactStagingDirectory)/test-results-$(TEST_GROUP).xml'
            testRunTitle: '$(DISPLAY_NAME)'
            failTaskOnFailedTests: true
          condition: always()
          displayName: 'Publish $(DISPLAY_NAME) Test Results'
        # Cleanup: stop emulator services and mock site
        - script: |
            echo "Cleaning up services for $(DISPLAY_NAME)..."

            # Stop mock site if PID is available
            if [ ! -z "$MOCK_SITE_PID" ]; then
              echo "Stopping mock site (PID: $MOCK_SITE_PID)"
              kill $MOCK_SITE_PID 2>/dev/null || true
            fi

            # Stop any remaining mock-extension-site processes
            pkill -f mock-extension-site || true

            # Stop emulators based on what was started
            if [ "$(ADDITIONAL_EMULATORS)" = "cosmosdb" ]; then
              echo "Stopping CosmosDB emulator..."
              docker stop cosmosdb-emulator || true
              docker container rm --force cosmosdb-emulator || true
            elif [ "$(ADDITIONAL_EMULATORS)" = "mysql" ]; then
              echo "Stopping MySQL emulator..."
              cd tests/emulator_tests/utils/mysql
              docker compose down -v
            elif [ "$(ADDITIONAL_EMULATORS)" = "dts" ]; then
              echo "Stopping DTS emulator..."
              cd tests/emulator_tests/utils/dts
              docker compose down -v
            elif [ "$(ADDITIONAL_EMULATORS)" = "servicebus" ]; then
              echo "Stopping Service Bus emulator..."
              cd tests/emulator_tests/utils/servicebus
              docker compose down -v
            fi

            # Stop base emulators (EventHub/Azurite) - unless EventHub was stopped for Service Bus
            if [ "$(STOP_EVENTHUB)" != "true" ]; then
              echo "Stopping base emulators..."
              cd tests/emulator_tests/utils/eventhub
              docker compose down -v
            fi

            echo "Cleanup completed for $(DISPLAY_NAME)"
          displayName: 'Cleanup Services'
          condition: always()
