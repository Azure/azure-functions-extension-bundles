# Azure Functions Extension Bundle - Parallel Emulator Tests CI Job Template
#
# This template runs emulator-based tests in parallel using matrix strategy
# Each test group runs with its required emulators to optimize execution time
# Azurite (Storage) and EventHub are started for all test groups as base requirements
parameters:
  - name: official
    type: boolean
    default: false

  - name: poolName
    type: string

jobs:
# New preparation job to build/publish once for all matrix runs
- job: PrepareEmulatorTestAssets
  displayName: Prepare Emulator Test Assets (build once)
  pool:
    name: ${{ parameters.poolName }}
    image: 1es-ubuntu-22.04
    os: linux
  # 1ES-compliant artifact publication via templateContext.outputs
  templateContext:
    outputs:
      - output: pipelineArtifact
        displayName: Publish bundle artifacts
        path: $(Build.Repository.LocalPath)/azure-functions-extension-bundles/artifacts
        artifact: bundle-artifacts
      - output: pipelineArtifact
        displayName: Publish bundle bin
        path: $(Build.Repository.LocalPath)/azure-functions-extension-bundles/bin
        artifact: bundle-bin
      - output: pipelineArtifact
        displayName: Publish templates artifacts
        path: $(Build.Repository.LocalPath)/azure-functions-extension-bundles/templatesArtifacts
        artifact: templates-artifacts
      - output: pipelineArtifact
        displayName: Publish core tools artifacts
        path: $(Build.Repository.LocalPath)/azure-functions-core-tools/coretools
        artifact: core-tools-artifacts

  steps:
  - checkout: self
  - checkout: coretools 
  
  # Download template artifacts for the build
  # Official templates
  - task: DownloadBuildArtifacts@1
    inputs:
      buildType: 'specific'
      project: '3f99e810-c336-441f-8892-84983093ad7f'
      pipeline: '963'
      buildVersionToDownload: 'latestFromBranch'
      branchName: 'refs/heads/dev'
      downloadType: 'single'
      artifactName: 'drop'
      downloadPath: '$(Build.Repository.LocalPath)/azure-functions-extension-bundles/templatesArtifacts'
    condition: ${{ parameters.official }}

  # Public templates
  - task: DownloadBuildArtifacts@1
    inputs:
      buildType: 'specific'
      project: 'ae7e3bf3-d41a-4480-9ac0-b6cf9df9ac24'
      pipeline: '976'
      buildVersionToDownload: 'latestFromBranch'
      branchName: 'refs/heads/dev'
      downloadType: 'single'
      artifactName: 'drop'
      downloadPath: '$(Build.Repository.LocalPath)/azure-functions-extension-bundles/templatesArtifacts'
    condition: ${{ eq(parameters.official, false) }}

  - task: NuGetAuthenticate@1
    displayName: 'NuGet Authenticate'
    
  - task: PowerShell@2
    displayName: 'Build Azure Functions Core Tools'
    inputs:
      filePath: '$(Build.Repository.LocalPath)/azure-functions-extension-bundles/eng/ci/scripts/build-core-tools.ps1'
      arguments: '-Branch main -Configuration Release -CloneDir "$(Build.Repository.LocalPath)/azure-functions-core-tools"'
      pwsh: true
      workingDirectory: '$(Build.Repository.LocalPath)/azure-functions-core-tools'

  - task: DotNetCoreCLI@2
    displayName: 'Build Linux Bundle (once)'
    inputs:
      command: 'run'
      workingDirectory: '$(Build.Repository.LocalPath)/azure-functions-extension-bundles/build'
      arguments: 'PackageNetCoreV3BundlesLinux'
    env:
      BUILD_REPOSITORY_LOCALPATH: '$(Build.Repository.LocalPath)'
      TEMPLATES_ARTIFACTS_DIRECTORY: '$(Build.Repository.LocalPath)/azure-functions-extension-bundles/templatesArtifacts'

  - script: |
      echo "Checking for build artifacts..."
      if ls azure-functions-core-tools/coretools/*.zip 2>/dev/null || ls azure-functions-extension-bundles/artifacts/*.zip 2>/dev/null || ls azure-functions-extension-bundles/bin/*/*.zip 2>/dev/null; then
        echo "✓ Extension bundle and core tools artifacts found"
      else
        echo "✗ No extension bundle or core tools zip files found anywhere"
        exit 1
      fi
    displayName: 'Verify Build Artifacts'

# Matrix job now depends on the preparation job and reuses its artifacts
- job: EmulatorTests
  displayName: Run Emulator Tests
  dependsOn: PrepareEmulatorTestAssets
  pool:
    name: ${{ parameters.poolName }}
    image: 1es-ubuntu-22.04
    os: linux
  # Matrix strategy for parallel execution by emulator group
  strategy:
    matrix:
      BasicTests:
        TEST_GROUP: 'basic'
        TEST_FILES: 'test_blob_functions.py test_connectivity.py test_eventhub_batch_functions.py test_eventhub_functions.py test_queue_functions.py test_table_functions.py'
        ADDITIONAL_EMULATORS: 'none'
        DISPLAY_NAME: 'Basic Tests (Azurite + EventHub)'
        STOP_EVENTHUB: 'false'
      CosmosDB:
        TEST_GROUP: 'cosmosdb'
        TEST_FILES: 'test_cosmosdb_functions.py'
        ADDITIONAL_EMULATORS: 'cosmosdb'
        DISPLAY_NAME: 'CosmosDB Tests'
        STOP_EVENTHUB: 'false'
      MySQL:
        TEST_GROUP: 'mysql'
        TEST_FILES: 'test_mysql_functions.py'
        ADDITIONAL_EMULATORS: 'mysql'
        DISPLAY_NAME: 'MySQL Tests'
        STOP_EVENTHUB: 'false'
      ServiceBus:
        TEST_GROUP: 'servicebus'
        TEST_FILES: 'test_servicebus_functions.py'
        ADDITIONAL_EMULATORS: 'servicebus'
        DISPLAY_NAME: 'Service Bus Tests'
        STOP_EVENTHUB: 'true'
      DurableTaskScheduler:
        TEST_GROUP: 'dts'
        TEST_FILES: 'test_durable_functions.py'
        ADDITIONAL_EMULATORS: 'dts'
        DISPLAY_NAME: 'Durable Task Scheduler Tests'
        STOP_EVENTHUB: 'false'

  templateContext:
    outputParentDirectory: $(Build.ArtifactStagingDirectory)
    outputs:
      - output: pipelineArtifact
        displayName: Publish emulator test artifacts for $(TEST_GROUP)
        path: $(Build.ArtifactStagingDirectory)
        artifact: emulator-test-results-$(TEST_GROUP)

  steps:
  # Initial listing for debugging (added)
  - script: |
      echo "=== Initial workspace listing ==="
      pwd
      ls -al .
      for d in artifacts bin templatesArtifacts tests; do
        echo "--- $d ---";
        ls -al "$d" 2>/dev/null || echo "(missing)"; done
    displayName: 'Initial Workspace Listing'

  # Download prepared artifacts (instead of rebuilding)
  - task: DownloadPipelineArtifact@2
    displayName: 'Download bundle artifacts'
    inputs:
      artifact: 'core-tools-artifacts'
      path: '$(Build.Repository.LocalPath)/core-tools'

  - task: DownloadPipelineArtifact@2
    displayName: 'Download bundle artifacts'
    inputs:
      artifact: 'bundle-artifacts'
      path: '$(Build.Repository.LocalPath)/artifacts'

  - task: DownloadPipelineArtifact@2
    displayName: 'Download bundle bin'
    inputs:
      artifact: 'bundle-bin'
      path: '$(Build.Repository.LocalPath)/bin'

  - task: DownloadPipelineArtifact@2
    displayName: 'Download templates artifacts'
    inputs:
      artifact: 'templates-artifacts'
      path: '$(Build.Repository.LocalPath)/templatesArtifacts'

  - script: |
      echo "Listing downloaded directories..."
      ls -al artifacts || true
      ls -al bin || true
      ls -al templatesArtifacts || true
      ls -al core-tools || true
      echo "Checking for downloaded artifacts..."
      if ls artifacts/*.zip 2>/dev/null || ls bin/*/*.zip 2>/dev/null; then
        echo "✓ Extension bundle artifacts downloaded"
        echo "Artifacts:"
        ls -1 artifacts/*.zip 2>/dev/null || true
        ls -1 bin/*/*.zip 2>/dev/null || true
        ls -1 core-tools/*.zip 2>/dev/null || true
      else
        echo "✗ No extension bundle zip files found"
        find . -maxdepth 5 -type f -name '*.zip' -print || true
        exit 1
      fi
    displayName: 'Verify Downloaded Artifacts'

  # Set up Python 3.12 and create virtual environment
  - task: UsePythonVersion@0
    inputs:
      versionSpec: '3.12'
      addToPath: true
      architecture: 'x64'
    displayName: 'Set up Python 3.12'

  - script: |
      cd tests
      python -m venv venv
      source venv/bin/activate
      pip install --upgrade pip
      pip install --cache-dir ~/.cache/pip -r requirements.txt
    displayName: 'Install Python Dependencies (cached)'

  # Start base emulators (Azurite + EventHub) - Required for ALL test groups
  - script: |
      echo "Starting base emulators (Azurite + EventHub) for $(DISPLAY_NAME)..."
      cd tests/emulator_tests/utils/eventhub
      docker compose pull
      docker compose up -d
      echo "Waiting for base emulator services to start..."
      sleep 30
      docker compose ps
      echo "Base emulators started successfully"
    displayName: 'Start Base Emulators (Azurite + EventHub)'

  # Conditionally start additional emulators based on test group
  - script: |
      if [ "$(ADDITIONAL_EMULATORS)" = "cosmosdb" ]; then
        echo "Starting CosmosDB Emulator for $(DISPLAY_NAME)..."
        docker pull mcr.microsoft.com/cosmosdb/linux/azure-cosmos-emulator:vnext-preview
        docker run --detach --publish 8081:8081 --publish 1234:1234 --name cosmosdb-emulator mcr.microsoft.com/cosmosdb/linux/azure-cosmos-emulator:vnext-preview
        echo "Waiting for CosmosDB Emulator to start..."
        sleep 60
        docker ps
      elif [ "$(ADDITIONAL_EMULATORS)" = "mysql" ]; then
        echo "Starting MySQL Emulator for $(DISPLAY_NAME)..."
        cd tests/emulator_tests/utils/mysql
        docker compose up -d
        echo "Waiting for MySQL service to start..."
        sleep 30
        docker compose ps
      elif [ "$(ADDITIONAL_EMULATORS)" = "servicebus" ]; then
        # Stop EventHub first to avoid port conflicts
        if [ "$(STOP_EVENTHUB)" = "true" ]; then
          echo "Stopping EventHub Emulator to free up ports for Service Bus..."
          docker stop eventhubs-emulator || true
          docker container rm --force eventhubs-emulator || true
        fi
        
        echo "Starting Service Bus Emulator for $(DISPLAY_NAME)..."
        cd tests/emulator_tests/utils/servicebus
        docker compose pull
        docker compose up -d
        echo "Waiting for Service Bus emulator to start..."
        sleep 30
        docker compose ps
      elif [ "$(ADDITIONAL_EMULATORS)" = "dts" ]; then
        echo "Starting DTS Emulator for $(DISPLAY_NAME)..."
        cd tests/emulator_tests/utils/dts
        docker compose up -d
        echo "Waiting for DTS emulator to start..."
        sleep 30
        docker compose ps
      else
        echo "No additional emulators required for $(DISPLAY_NAME)"
      fi
    displayName: 'Start Additional Emulators'
    env:
      AzureWebJobsSQLPassword: $(AzureWebJobsSQLPassword)

  # Start mock extension site in background
  - script: |
      cd tests
      source venv/bin/activate
      echo "Starting mock extension site on port 8000 for $(DISPLAY_NAME)..."
      
      python -m invoke -c test_setup mock-extension-site --port 8000 &

      MOCK_SITE_PID=$!
      echo "Mock site started with PID: $MOCK_SITE_PID"
      echo "##vso[task.setvariable variable=MOCK_SITE_PID]$MOCK_SITE_PID"
      sleep 10
      
      # Verify mock site is running on port 8000
      if curl -f http://localhost:8000/ 2>/dev/null; then
        echo "✅ Mock extension site is running successfully on port 8000"
        echo "Extension bundle source URI: http://localhost:8000"
      else
        echo "❌ Warning: Mock extension site may not be responding on port 8000"
        netstat -tlnp | grep :8000 || true
      fi
    displayName: 'Start Mock Extension Site'

  # Run tests for this specific test group
  - script: |
      cd tests
      source venv/bin/activate
      cd ..
      export PYAZURE_WEBHOST_DEBUG=1
      export FUNCTIONS_EXTENSIONBUNDLE_SOURCE_URI="http://localhost:8000"
      export MySqlConnectionString="Server=localhost;UserID=root;Password=password;Database=testdb;Port=3307"
      IFS=' ' read -ra FILES <<< "$(TEST_FILES)"
      TEST_PATHS=""
      for file in "${FILES[@]}"; do
        TEST_PATHS="$TEST_PATHS tests/emulator_tests/$file"
      done
      echo "Running pytest with paths: $TEST_PATHS"
      python -m pytest $TEST_PATHS -v --tb=short --junitxml=$(Build.ArtifactStagingDirectory)/test-results-$(TEST_GROUP).xml
    displayName: 'Run $(DISPLAY_NAME) Tests'
    env:
      PYAZURE_WEBHOST_DEBUG: 1
      FUNCTIONS_EXTENSIONBUNDLE_SOURCE_URI: "http://localhost:8000"
      AzureWebJobsStorage: "UseDevelopmentStorage=true"
      AzureWebJobsEventHubConnectionString: $(EmulatorEventHubConnectionString)
      AzureWebJobsCosmosDBConnectionString: $(EmulatorCosmosDBConnectionString)
      AzureWebJobsServiceBusConnectionString: $(EmulatorServiceBusConnectionString)
      AzureWebJobsSQLPassword: $(AzureWebJobsSQLPassword)
      CosmosDBEmulatorUrl: $(CosmosDBEmulatorUrl)
      CosmosDBEmulatorKey: $(CosmosDBEmulatorKey)

  # Copy webhost config for debugging
  - script: |
      if [ -f tests/webhost_config.txt ]; then
        cp tests/webhost_config.txt $(Build.ArtifactStagingDirectory)/
        echo "WebHost config copied for artifact upload"
      else
        echo "Warning: webhost_config.txt not found"
      fi
    displayName: 'Copy WebHost Config'
    condition: always()

  # Publish test results
  - task: PublishTestResults@2
    inputs:
      testResultsFiles: '$(Build.ArtifactStagingDirectory)/test-results-$(TEST_GROUP).xml'
      testRunTitle: '$(DISPLAY_NAME)'
      failTaskOnFailedTests: true
    condition: always()
    displayName: 'Publish $(DISPLAY_NAME) Test Results'

  # Cleanup: stop emulator services and mock site
  - script: |
      echo "Cleaning up services for $(DISPLAY_NAME)..."
      
      # Stop mock site if PID is available
      if [ ! -z "$MOCK_SITE_PID" ]; then
        echo "Stopping mock site (PID: $MOCK_SITE_PID)"
        kill $MOCK_SITE_PID 2>/dev/null || true
      fi
      
      # Stop any remaining mock-extension-site processes
      pkill -f mock-extension-site || true
      
      # Stop emulators based on what was started
      if [ "$(ADDITIONAL_EMULATORS)" = "cosmosdb" ]; then
        echo "Stopping CosmosDB emulator..."
        docker stop cosmosdb-emulator || true
        docker container rm --force cosmosdb-emulator || true
      elif [ "$(ADDITIONAL_EMULATORS)" = "mysql" ]; then
        echo "Stopping MySQL emulator..."
        cd tests/emulator_tests/utils/mysql
        docker compose down -v
      elif [ "$(ADDITIONAL_EMULATORS)" = "servicebus" ]; then
        echo "Stopping Service Bus emulator..."
        cd tests/emulator_tests/utils/servicebus
        docker compose down -v
      elif [ "$(ADDITIONAL_EMULATORS)" = "dts" ]; then
        echo "Stopping DTS emulator..."
        cd tests/emulator_tests/utils/dts
        docker compose down -v
      fi
      
      # Stop base emulators (EventHub/Azurite) - unless EventHub was stopped for Service Bus
      if [ "$(STOP_EVENTHUB)" != "true" ]; then
        echo "Stopping base emulators..."
        cd tests/emulator_tests/utils/eventhub
        docker compose down -v
      fi
      
      echo "Cleanup completed for $(DISPLAY_NAME)"
    displayName: 'Cleanup Services'
    condition: always()
