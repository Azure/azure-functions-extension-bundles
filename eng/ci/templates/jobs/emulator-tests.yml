# Azure Functions Extension Bundle - Parallel Emulator Tests CI Job Template
#
# This template runs emulator-based tests in parallel using matrix strategy
# Each test group runs with its required emulators to optimize execution time
# Azurite (Storage) and EventHub are started for all test groups as base requirements
parameters:
  - name: official
    type: boolean
    default: false

  - name: poolName
    type: string

jobs:
# Parallel preparation jobs for better performance
# Job 1: Build Core Tools
- job: PrepareCoreTools
  displayName: Build Core Tools
  pool:
    name: ${{ parameters.poolName }}
    image: 1es-ubuntu-22.04
    os: linux
  templateContext:
    outputs:
      - output: pipelineArtifact
        displayName: Publish core tools artifacts
        path: $(Agent.BuildDirectory)/core-tools/artifacts-coretools-zip
        artifact: core-tools-artifacts

  steps:
  - checkout: self
    path: bundle
    fetchDepth: 1
    sparseCheckoutDirectories: eng
    
  - checkout: coretools
    path: core-tools
    fetchDepth: 1

  - script: |
      echo "Disk space before build:"
      df -h
    displayName: 'Check Initial Disk Space'
  
  - task: NuGetAuthenticate@1
    displayName: 'NuGet Authenticate'
    
  - task: PowerShell@2
    displayName: 'Build Azure Functions Core Tools'
    inputs:
      filePath: '$(Agent.BuildDirectory)/bundle/eng/ci/scripts/build-multi-version-core-tools.ps1'
      arguments: '-Count $(hostTagsCount) -Pattern "$(hostTagPattern)" -Configuration Release -CloneDir "$(Agent.BuildDirectory)/core-tools"'
      pwsh: true
      workingDirectory: '$(Agent.BuildDirectory)/core-tools'
  
  - script: |
      echo "Cleaning up build artifacts to free disk space..."
      
      # Remove source code (keep only artifacts)
      echo "Removing Core Tools source files..."
      find $(Agent.BuildDirectory)/core-tools -type f -name "*.cs" -delete 2>/dev/null || true
      find $(Agent.BuildDirectory)/core-tools -type d -name "obj" -exec rm -rf {} + 2>/dev/null || true
      find $(Agent.BuildDirectory)/core-tools -type d -name "bin" ! -path "*/artifacts-coretools-zip/*" -exec rm -rf {} + 2>/dev/null || true
      
      # Clean NuGet cache
      echo "Clearing NuGet cache..."
      rm -rf ~/.nuget/packages/* 2>/dev/null || true
      
      # Remove git history from core-tools to save space
      echo "Removing git history..."
      rm -rf $(Agent.BuildDirectory)/core-tools/.git 2>/dev/null || true
      
      echo "Disk space after cleanup:"
      df -h
    displayName: 'Cleanup After Core Tools Build'
  
# Job 2: Build Extension Bundle (downloads template artifacts)
- job: PrepareBundle
  displayName: Build Extension Bundle
  pool:
    name: ${{ parameters.poolName }}
    image: 1es-ubuntu-22.04
    os: linux
  # 1ES-compliant artifact publication via templateContext.outputs
  templateContext:
    outputs:
      - output: pipelineArtifact
        displayName: Publish bundle artifacts
        path: $(Build.Repository.LocalPath)/artifacts
        artifact: bundle-artifacts

  steps:
  # Download template artifacts for the build
  # Official templates
  - task: DownloadBuildArtifacts@1
    inputs:
      buildType: 'specific'
      project: '3f99e810-c336-441f-8892-84983093ad7f'
      pipeline: '963'
      buildVersionToDownload: 'latestFromBranch'
      branchName: 'refs/heads/dev'
      downloadType: 'single'
      artifactName: 'drop'
      downloadPath: '$(Build.Repository.LocalPath)/templatesArtifacts'
    condition: ${{ parameters.official }}

  # Public templates
  - task: DownloadBuildArtifacts@1
    inputs:
      buildType: 'specific'
      project: 'ae7e3bf3-d41a-4480-9ac0-b6cf9df9ac24'
      pipeline: '976'
      buildVersionToDownload: 'latestFromBranch'
      branchName: 'refs/heads/dev'
      downloadType: 'single'
      artifactName: 'drop'
      downloadPath: '$(Build.Repository.LocalPath)/templatesArtifacts'
    condition: ${{ eq(parameters.official, false) }}

  - task: NuGetAuthenticate@1
    displayName: 'NuGet Authenticate'
    
  - task: DotNetCoreCLI@2
    displayName: 'Build Linux Bundle (once)'
    inputs:
      command: 'run'
      workingDirectory: './build'
      arguments: 'skip:GenerateVulnerabilityReport,PackageNetCoreV3Bundle,PackageNetCoreV3BundlesWindows,CreateRUPackage,CreateCDNStoragePackage,CreateCDNStoragePackageWindows'
    env:
      BUILD_REPOSITORY_LOCALPATH: '$(Build.Repository.LocalPath)'
      TEMPLATES_ARTIFACTS_DIRECTORY: '$(Build.Repository.LocalPath)/templatesArtifacts'

  - script: |
      echo "Checking for build artifacts..."
      if ls artifacts/*.zip 2>/dev/null || ls bin/*/*.zip 2>/dev/null; then
        echo "✓ Extension bundle artifacts found"
      else
        echo "✗ No extension bundle zip files found anywhere"
        exit 1
      fi
    displayName: 'Verify Build Artifacts'

# Job 3: Generate dynamic matrix for all Core Tools versions × Test Groups
- job: GenerateTestMatrix
  displayName: Generate Test Matrix
  dependsOn: PrepareCoreTools
  pool:
    name: ${{ parameters.poolName }}
    image: 1es-ubuntu-22.04
    os: linux
  
  steps:
  - task: PowerShell@2
    displayName: 'Generate Dynamic Matrix'
    inputs:
      targetType: 'inline'
      script: |
        # Validate required pipeline variables
        if ([string]::IsNullOrEmpty("$(hostTagsCount)")) {
          Write-Error "hostTagsCount pipeline variable is not set"
          exit 1
        }
        
        try {
          $hostTagsCount = [int]"$(hostTagsCount)"
        } catch {
          Write-Error "hostTagsCount must be a valid integer. Got: $(hostTagsCount)"
          exit 1
        }
        
        if ($hostTagsCount -lt 1) {
          Write-Error "hostTagsCount must be at least 1. Got: $hostTagsCount"
          exit 1
        }
        
        Write-Host "Generating matrix for $hostTagsCount host version(s)"
        
        # Load test group definitions from external config file
        $configPath = "$(Build.SourcesDirectory)/eng/ci/config/test-groups.json"
        if (-not (Test-Path $configPath)) {
          Write-Error "Test groups config file not found: $configPath"
          exit 1
        }
        
        $config = Get-Content $configPath -Raw | ConvertFrom-Json
        $testGroups = $config.testGroups | ForEach-Object {
          @{
            Name = $_.name
            Group = $_.group
            Files = $_.files
            Emulators = $_.emulators
            Display = $_.display
            StopEventHub = $_.stopEventHub
          }
        }
        
        # Generate matrix: version index X test group (e.g., 1_CosmosDB, 1_MySQL, 2_CosmosDB, 2_MySQL)
        $matrix = @{}
        for ($versionIndex = 1; $versionIndex -le $hostTagsCount; $versionIndex++) {
          foreach ($group in $testGroups) {
            # Create job key like "1_CosmosDB", "2_MySQL", etc.
            $key = "${versionIndex}_$($group.Name)"
            $matrix[$key] = @{
              HOST_INDEX = $versionIndex
              TEST_GROUP = $group.Group
              TEST_FILES = $group.Files
              ADDITIONAL_EMULATORS = $group.Emulators
              DISPLAY_NAME = "${versionIndex}-$($group.Display)"
              STOP_EVENTHUB = $group.StopEventHub
            }
          }
        }
        
        if ($matrix.Count -eq 0) {
          Write-Error "Failed to generate test matrix - no jobs created"
          exit 1
        }
        
        $matrixJson = $matrix | ConvertTo-Json -Compress -Depth 10
        Write-Host "Generated matrix with $($matrix.Count) job(s):"
        $matrix.Keys | Sort-Object | ForEach-Object {
          Write-Host "  - $_ : $($matrix[$_].DISPLAY_NAME)"
        }
        
        if ([string]::IsNullOrEmpty($matrixJson)) {
          Write-Error "Matrix JSON serialization failed"
          exit 1
        }
        
        Write-Host "##vso[task.setvariable variable=TestMatrix;isOutput=true]$matrixJson"
      pwsh: true
    name: MatrixGen

- job: EmulatorTests
  displayName: Run Emulator Tests
  dependsOn:
    - PrepareCoreTools
    - PrepareBundle
    - GenerateTestMatrix
  pool:
    name: ${{ parameters.poolName }}
    image: 1es-ubuntu-22.04
    os: linux
  strategy:
    maxParallel: 5
    matrix: $[ dependencies.GenerateTestMatrix.outputs['MatrixGen.TestMatrix'] ]

  templateContext:
    outputParentDirectory: $(Build.ArtifactStagingDirectory)
    outputs:
      - output: pipelineArtifact
        displayName: Publish emulator test artifacts for $(DISPLAY_NAME)
        path: $(Build.ArtifactStagingDirectory)
        artifact: emulator-test-results-$(HOST_INDEX)-$(TEST_GROUP)

  steps:
  # Download prepared artifacts
  - task: DownloadPipelineArtifact@2
    displayName: 'Download core tools artifacts'
    inputs:
      artifact: 'core-tools-artifacts'
      path: '$(Build.Repository.LocalPath)/core-tools'

  - task: DownloadPipelineArtifact@2
    displayName: 'Download bundle artifacts'
    inputs:
      artifact: 'bundle-artifacts'
      path: '$(Build.Repository.LocalPath)/artifacts'

  - script: |
      echo "Testing: $(DISPLAY_NAME)"
      echo "Host Index: $(HOST_INDEX)"
      echo "Test Group: $(TEST_GROUP)"
      echo "Verifying Core Tools artifact for index $(HOST_INDEX)..."
      
      # Find the zip file matching this exact index using regex.
      CORE_TOOLS_ZIP=$(ls core-tools/ | grep -E "^$(HOST_INDEX)-cli-host-.+\.zip$" | head -n1)
      
      if [ -n "$CORE_TOOLS_ZIP" ]; then
        CORE_TOOLS_ZIP="core-tools/$CORE_TOOLS_ZIP"
        echo "✓ Found Core Tools zip: $CORE_TOOLS_ZIP"
        # Extract version from filename for HOST_VERSION env var
        HOST_VERSION=$(basename "$CORE_TOOLS_ZIP" | sed -E 's/^[0-9]+-cli-host-(.+)\.zip$/\1/')
        echo "##vso[task.setvariable variable=HOST_VERSION]$HOST_VERSION"
        echo "##vso[task.setvariable variable=CORE_TOOLS_ZIP]$(basename "$CORE_TOOLS_ZIP")"
        echo "Extracted version: $HOST_VERSION"
      else
        echo "✗ Missing Core Tools zip for index $(HOST_INDEX)"
        echo "Available Core Tools zips:"
        ls -1 core-tools/*.zip 2>/dev/null || true
        exit 1
      fi
    displayName: 'Verify Core Tools Artifact'

  # Set up Python 3.12 and create virtual environment
  - task: UsePythonVersion@0
    inputs:
      versionSpec: '3.12'
      addToPath: true
      architecture: 'x64'
    displayName: 'Set up Python 3.12'

  - script: |
      cd tests
      python -m venv venv
      source venv/bin/activate
      pip install --upgrade pip
      pip install --cache-dir ~/.cache/pip -r requirements.txt
    displayName: 'Install Python Dependencies (cached)'

  # Start base emulators (Azurite + EventHub) - Required for ALL test groups
  - script: |
      echo "Starting base emulators (Azurite + EventHub) for $(DISPLAY_NAME)..."
      cd tests/emulator_tests/utils/eventhub
      docker compose pull
      docker compose up -d
      echo "Waiting for base emulator services to start..."
      sleep 30
      docker compose ps
      echo "Base emulators started successfully"
    displayName: 'Start Base Emulators (Azurite + EventHub)'

  # Conditionally start additional emulators based on test group
  - script: |
      if [ "$(ADDITIONAL_EMULATORS)" = "cosmosdb" ]; then
        echo "Starting CosmosDB Emulator for $(DISPLAY_NAME)..."
        docker pull mcr.microsoft.com/cosmosdb/linux/azure-cosmos-emulator:vnext-preview
        docker run --detach --publish 8081:8081 --publish 1234:1234 --name cosmosdb-emulator mcr.microsoft.com/cosmosdb/linux/azure-cosmos-emulator:vnext-preview
        echo "Waiting for CosmosDB Emulator to start..."
        sleep 60
        docker ps
      elif [ "$(ADDITIONAL_EMULATORS)" = "mysql" ]; then
        echo "Starting MySQL Emulator for $(DISPLAY_NAME)..."
        cd tests/emulator_tests/utils/mysql
        docker compose up -d
        echo "Waiting for MySQL service to start..."
        sleep 30
        docker compose ps
      elif [ "$(ADDITIONAL_EMULATORS)" = "servicebus" ]; then
        # Stop EventHub first to avoid port conflicts
        if [ "$(STOP_EVENTHUB)" = "true" ]; then
          echo "Stopping EventHub Emulator to free up ports for Service Bus..."
          docker stop eventhubs-emulator || true
          docker container rm --force eventhubs-emulator || true
        fi
        
        echo "Starting Service Bus Emulator for $(DISPLAY_NAME)..."
        cd tests/emulator_tests/utils/servicebus
        docker compose pull
        docker compose up -d
        echo "Waiting for Service Bus emulator to start..."
        sleep 30
        docker compose ps
      elif [ "$(ADDITIONAL_EMULATORS)" = "dts" ]; then
        echo "Starting DTS Emulator for $(DISPLAY_NAME)..."
        cd tests/emulator_tests/utils/dts
        docker compose up -d
        echo "Waiting for DTS emulator to start..."
        sleep 30
        docker compose ps
      else
        echo "No additional emulators required for $(DISPLAY_NAME)"
      fi
    displayName: 'Start Additional Emulators'
    env:
      AzureWebJobsSQLPassword: $(AzureWebJobsSQLPassword)

  # Start mock extension site in background
  - script: |
      cd tests
      source venv/bin/activate
      echo "Starting mock extension site on port 8000 for $(DISPLAY_NAME)..."
      
      python -m invoke -c test_setup mock-extension-site --port 8000 &

      MOCK_SITE_PID=$!
      echo "Mock site started with PID: $MOCK_SITE_PID"
      echo "##vso[task.setvariable variable=MOCK_SITE_PID]$MOCK_SITE_PID"
      sleep 10
      
      # Verify mock site is running on port 8000
      if curl -f http://localhost:8000/ 2>/dev/null; then
        echo "✅ Mock extension site is running successfully on port 8000"
        echo "Extension bundle source URI: http://localhost:8000"
      else
        echo "❌ Warning: Mock extension site may not be responding on port 8000"
        netstat -tlnp | grep :8000 || true
      fi
    displayName: 'Start Mock Extension Site'
  
  # Run tests for the specific Core Tools version assigned to this job
  - script: |
      cd tests
      source venv/bin/activate
      cd ..
      
      echo "=========================================="
      echo "Testing: $(DISPLAY_NAME)"
      echo "Host Version: $(HOST_VERSION)"
      echo "=========================================="
      
      # Set up webhost for this specific version
      cd tests
      python -m invoke -c test_setup webhost
      cd ..
      
      # Run tests
      export PYAZURE_WEBHOST_DEBUG=1
      export FUNCTIONS_EXTENSIONBUNDLE_SOURCE_URI="http://localhost:8000"
      export MySqlConnectionString="Server=localhost;UserID=root;Password=password;Database=testdb;Port=3307"
      
      IFS=' ' read -ra FILES <<< "$(TEST_FILES)"
      TEST_PATHS=""
      for file in "${FILES[@]}"; do
        TEST_PATHS="$TEST_PATHS tests/emulator_tests/$file"
      done
      
      echo "Running pytest with paths: $TEST_PATHS"
      
      # Run tests - only one version per job now, so no loop needed
      python -m pytest $TEST_PATHS -v --tb=short --junitxml=$(Build.ArtifactStagingDirectory)/test-results-$(HOST_INDEX)-$(TEST_GROUP).xml
    displayName: 'Run $(DISPLAY_NAME)'
    env:
      HOST_VERSION: $(HOST_VERSION)
      PYAZURE_WEBHOST_DEBUG: 1
      FUNCTIONS_EXTENSIONBUNDLE_SOURCE_URI: "http://localhost:8000"
      AzureWebJobsStorage: "UseDevelopmentStorage=true"
      AzureWebJobsEventHubConnectionString: $(EmulatorEventHubConnectionString)
      AzureWebJobsCosmosDBConnectionString: $(EmulatorCosmosDBConnectionString)
      AzureWebJobsServiceBusConnectionString: $(EmulatorServiceBusConnectionString)
      AzureWebJobsSQLPassword: $(AzureWebJobsSQLPassword)
      CosmosDBEmulatorUrl: $(CosmosDBEmulatorUrl)
      CosmosDBEmulatorKey: $(CosmosDBEmulatorKey)

  # Copy webhost config for debugging
  - script: |
      if [ -f tests/webhost_config.txt ]; then
        cp tests/webhost_config.txt $(Build.ArtifactStagingDirectory)/
        echo "WebHost config copied for artifact upload"
      else
        echo "Warning: webhost_config.txt not found"
      fi
    displayName: 'Copy WebHost Config'
    condition: always()

  # Publish test results
  - task: PublishTestResults@2
    inputs:
      testResultsFiles: '$(Build.ArtifactStagingDirectory)/test-results-$(HOST_INDEX)-$(TEST_GROUP).xml'
      testRunTitle: '$(DISPLAY_NAME)'
      failTaskOnFailedTests: true
    condition: always()
    displayName: 'Publish Test Results'

  # Cleanup: stop emulator services and mock site
  - script: |
      echo "Cleaning up services for $(DISPLAY_NAME)..."
      
      # Stop mock site if PID is available
      if [ ! -z "$MOCK_SITE_PID" ]; then
        echo "Stopping mock site (PID: $MOCK_SITE_PID)"
        kill $MOCK_SITE_PID 2>/dev/null || true
      fi
      
      # Stop any remaining mock-extension-site processes
      pkill -f mock-extension-site || true
      
      # Stop emulators based on what was started
      if [ "$(ADDITIONAL_EMULATORS)" = "cosmosdb" ]; then
        echo "Stopping CosmosDB emulator..."
        docker stop cosmosdb-emulator || true
        docker container rm --force cosmosdb-emulator || true
      elif [ "$(ADDITIONAL_EMULATORS)" = "mysql" ]; then
        echo "Stopping MySQL emulator..."
        cd tests/emulator_tests/utils/mysql
        docker compose down -v
      elif [ "$(ADDITIONAL_EMULATORS)" = "servicebus" ]; then
        echo "Stopping Service Bus emulator..."
        cd tests/emulator_tests/utils/servicebus
        docker compose down -v
      elif [ "$(ADDITIONAL_EMULATORS)" = "dts" ]; then
        echo "Stopping DTS emulator..."
        cd tests/emulator_tests/utils/dts
        docker compose down -v
      fi
      
      # Stop base emulators (EventHub/Azurite) - unless EventHub was stopped for Service Bus
      if [ "$(STOP_EVENTHUB)" != "true" ]; then
        echo "Stopping base emulators..."
        cd tests/emulator_tests/utils/eventhub
        docker compose down -v
      fi
      
      echo "Cleanup completed for $(DISPLAY_NAME)"
    displayName: 'Cleanup Services'
    condition: always()
